# TestReviesApp - выполнил: Мартынов Николай Владимирович
Стартовый проект для тестового задания в команду ВК.

## Примеры выполненного задания:

Минимальный вариант|Максимальный вариант|Ячейка количества отзывов
-|-|-
![Минимальный вариант](/Screenshots/1.png) | ![Максимальный вариант](/Screenshots/2.png) | ![Ячейка количества отзывов](/Screenshots/3.png)

# Итоговый результат (Выполнение):

## Доделал верстку до состояния ("Максимальный вариант")
[Снимок экрана]
### Добавил аватар пользователя
* Использовал оступы и закругления
* Сделал установку аватара по умолчанию
* Сделал загрузку аватара асинхронно с обновлением UI на главном потоке (подробнее в ...)
### Добавил имя пользователя в ячейку
* Имя и фамилия через пробел
* Сделал чтобы фамилия выводилась полностью (не обрезалась)
### Добавил изображение рейтинга в ячейку
* использовал RatingRenderer

[Снимок экрана] 
### Добавил нижнюю ячейку таблицы которая используеться для отображения количества отзывов (в качестве футера)
* Сделал отдельный класс для ячейки ReviewFooterCell
* Сделал конфигурацию ячейки для отображения футера с количеством отзывов в таблице [ReviewFooterCellConfig.swift]() - которая реализует протокол TableCellConfig для настройки и определения высоты ячейки.

[Снимок экрана] [Снимок экрана] 
### Сделал рабочую кнопку "Показать полностью..."
* Текст отзыва обрезается до трех строк
* При нажатии на кнопку текст раскрываеться и ячейка увеличивается (Сделал обрабочик нажатия)
* Кнопка "Показать полностью" показывается только если у неё ненулевой фрейм, иначе скрывается
* При изменении количества строк (раскрытие текста) идет пересчёт высоты

## Реализовал асинхронную загрузку и кэширование изображений
* Добавил в json файл поля "avatar_url" и "photo_urls"
```
{
            "first_name": "Евгения",
            "last_name": "Петрова",
            "rating": 4,
            "text": "Прошла по снегу 30 метров, 5 раз упала. Спасибо мужу, поддерживал. Возврат, к сожалению.",
            "created": "35 минут назад",
            "avatar_url": "https://cataas.com/cat",
            "photo_urls": ["https://cdn-images.farfetch-contents.com/24/93/56/95/24935695_55572239_1000.jpg","https://cdn-images.farfetch-contents.com/24/93/56/95/24935695_55572211_2048.jpg"]
        }
```
* Добавил в модель отзыва ключи для декодирования из JSON в свойства модели [Review.swift]()
* Реализовал кэширование на диск [ImageCache.swift]()
* При переиспользовании ячейки сбрасывались все картинки и состояния, чтобы избежать наложения
* Перед загрузкой новых фото сначала очищаю и скрываю все imageView для фотогорафий, чтобы не показывать старые
* При асинхронной загрузке картинок проверяю, что ячейка не переиспользована с другим config (сравниваю по id) — это предотвращает замену картинки не в той ячейке
* [ReviewCell.swift]()


## Реализовал pull-to-refresh через UIRefreshControl
* Добавил в [ReviewsViewController.swift]()
* Метод в [ReviewsViewModel.swift]() для обновления

[Снимок экрана]


## Сделал кастомный индикатор для состояния загрузки данных через CALayer с анимацией вращения круга
* При загрузке данных показывается кастомный индикатор поверх экрана
* Когда данные загрузились (событие через onStateChange), индикатор скрывается
* При pull-to-refresh индикатор также показывается и скрывается
* Кастомный индикатоор загрузки [CustomLoadingIndicator.swift]()

[Снимок экрана]

## Сделал экран просмотра фото при нажатии на фото в отзыве:
* открывается полноэкранный просмотр фото
* можно листать влево/вправо
* есть индикатор текущего фото 
* свайп вниз для закрытия просмотра
* Контроллер для просмотра изображений с постраничной навигацией [PhotoViewerViewController.swift]()

[Снимок экрана] [Снимок экрана]

## Предотвратил утечки памяти
**Проблема с замыканиями без [weak self]** - В Swift утечки памяти часто возникают из-за циклов удержания (retain cycles), когда замыкания захватывают сильную ссылку на self. Это препятствует освобождению объекта из памяти, так как замыкание и объект удерживают друг друга. Когда в замыкании используется self без указания [weak self] или [unowned self], замыкание создает сильную ссылку на объект, что увеличивает счетчик ссылок. Если объект также удерживает замыкание (например, через свойство), возникает цикл удержания — объект не может быть освобожден, пока замыкание существует, и наоборот. Использование [weak self] в списке захвата замыкания создает слабую ссылку на объект, которая не увеличивает счетчик ссылок. Это позволяет объекту быть освобожденным, даже если замыкание еще не выполнено.
  
Например в [ReviewsViewModel.swift]() использовал замыкание, вызываемое при нажатии на фото 
```
  onTapPhoto: { [weak self] urls, index in
                self?.onPhotoTap?(urls, index)
            }
```
В списке захвата замыкания указано [weak self], чтобы избежать сильного удержания self и, как следствие, утечки памяти.
* Если внутри замыкания использовать просто self, то замыкание удержит сильную ссылку на объект, в котором оно объявлено. Если этот объект также удерживает замыкание (например, через свойство), возникает цикл удержания и утечка памяти.
* Использование [weak self] создаёт слабую ссылку на self, которая не увеличивает счетчик ссылок. Если объект уже освобождён, self будет nil и вызов self?.onPhotoTap?(...) просто не выполнится.

## Решение проблемы с UI-перфомансом(плавностью скроллинга)
1. Загрузка больших изображений из диска может быть медленной. Даже если вы грузите в фоновом потоке, UIImage рендерится в основном потоке, и это тормозит. **Решено:** использование кэша изображений.
2.  Автолейаут в ячейках слишком тяжёлый. Если использовать layoutSubviews, и пересчитывать там фреймы (что сделано вручную), всё нормально, но: если внутри используются вложенные слои и они вызываются много раз, то возможны тормоза. **Решено:** ручная верстка интерфейса.

Другие типичные проблемы:

| Проблема 	| Последствия 	| Решение 	|
|---	|---	|---	|
| Большой размер изображения 	| лаги при скролле 	| уменьшить до нужного размера 	|
| Частые пересчёты лейаута 	| дергающийся UI 	| оптимизировать расчет высоты ячеек 	|
| Сложная логика в конфигурации ячейки 	| scroll тормозит 	| вынести тяжелое в viewModel 	|
| Недостатки переиспользования (reuse) ячеек в UITableView 	| много новых объектов 	| правильно регистрировать и использовать reuseIdentifier для переиспользования ячеек 	|
| Загрузка из сети в ячейку 	| тормоза 	| Использование предварительной загрузки изображений и кэша 	|


## Код-стайл
При разработке стрался придерживаться стиля кода Airbnb Swift Style. В общих требованиях указано, что в проекте не должно быть зависимостей. Проверить стиль кода с использованием Airbnb Swift Style Guide через Swift Package Manager не удалось, вариант проверить код без подключения зависимостей напрямую не предусмотрен, так как сам плагин работает в контексте пакета и его зависимостей.